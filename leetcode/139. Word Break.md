# 139. Word Break

[leetcode link](https://leetcode.com/problems/word-break/description/)      

**è¿”å› input s æ˜¯å¦å¯ä»¥ç”± wordDit ç»„æˆï¼Œdictionary é‡Œé¢çš„å•è¯å¯ä»¥ç”¨å¤šæ¬¡ã€‚**

**Example 1:**   
Input: s = "leetcode", 
wordDict = ["leet","code"]               
Output: true        

**Example 2:**
Input: s = "applepenapple",     wordDict = ["apple","pen"]      
Output: true        

**Example 3:**
Input: s = "catsandog",         wordDict = ["cats","dog","sand","and","cat"]        
Output: false       

**æœ¬é¢˜æœ€é«˜æ•ˆçš„è§£æ³• -> ğŸ”´ ã€ŒDPã€ orã€Œå¸¦å¤‡å¿˜å½•çš„ DFS ç®—æ³•ã€**

```java
Approach 1
            applepenapple
            /            \    x
        apple             pen           dfs é‡Œå¾ªç¯ word dictionary 
        /    \                          å»çœ‹æ˜¯å¦æœ‰åŒ¹é…çš„ substring
    apple x   pen
            /     \
        apple âœ“    pen x  

Approach 2 

å°† word dictionary å­˜åˆ° set é‡Œ
å¾ªç¯ string s å¦‚æœé‡åˆ°å¯ä»¥åŒ¹é…word
è¿›è¡Œä¸‹ä¸€å±‚çš„ dfs

            applepenapple
            /   |    \     \
        a      ap     ..    apple        
                           /  |   \
                          p  pe    pen
```

å¦‚æœ string s ç‰¹åˆ«é•¿ ä½†æ˜¯ word dictionary å¾ˆå°‘çš„è¯ï¼Œéå† word dictionaryã€‚      
ä½†å¦‚æœ word dictionary å¾ˆå¤š words çš„è¯ï¼Œå¯ä»¥ éå† string sï¼Œä»è€Œ O(1) æŸ¥çœ‹æ˜¯å¦æœ‰åŒ¹é…çš„ wordã€‚


## Approach 1 -> Time Limit
```java
class Solution {
    boolean found = false;
    public boolean wordBreak(String s, List<String> wordDict) {
        /*
                applepenapple
                /            \    x
            apple             pen
            /    \
        apple x   pen
                /     \
            apple âœ“    pen x  
        */
        dfs(s, wordDict, 0);
        return found;
    }

    private void dfs(String s, List<String> wordDict, int index) {
        if (found) {
            return;
        }
        if (index == s.length()) {
            found = true;
            return;
        }
        for (int i = 0; i < wordDict.size(); i++) {
            String cur = wordDict.get(i);
            int len = cur.length();
            if (index + len <= s.length() && 
                s.substring(index, len + index).equals(cur)) {
                dfs(s, wordDict, index + cur.length());
            }
            /* 
            boolean check = true;
            for (int j = 0; j < cur.length(); j++) {
                if (cur.charAt(j) != s.charAt(j + index)) {
                    check = false;
                    break;
                }
            }
            if (!check) continue;
            */
        }
    }
}
```

è®¾ `wordDict` çš„é•¿åº¦ä¸º `M`ï¼Œå­—ç¬¦ä¸² `s` çš„é•¿åº¦ä¸º `N`ï¼Œé‚£ä¹ˆè¿™æ®µä»£ç çš„æœ€åæ—¶é—´å¤æ‚åº¦æ˜¯ `O(MN)`ï¼ˆfor å¾ªç¯ `O(M)`ï¼ŒJava çš„ substring æ–¹æ³• `O(N)`ï¼‰ï¼Œæ‰€ä»¥æ€»çš„æ—¶é—´å¤æ‚åº¦æ˜¯ `O(2^N * MN)`ã€‚     

ä¼˜åŒ–ï¼šé€šè¿‡ç©·ä¸¾ `s[i..]` çš„å‰ç¼€å»åˆ¤æ–­ wordDict ä¸­æ˜¯å¦æœ‰å¯¹åº”çš„å•è¯

## Approach 2 -> Time Limit
```java
class Solution {
    Set<String> dict = new HashSet<>();
    boolean found;
    public boolean wordBreak(String s, List<String> wordDict) {
        for (int i = 0; i < wordDict.size(); i++) {
            dict.add(wordDict.get(i));
        }
        dfs(s, 0);
        return found;
    }

    private void dfs(String s, int index) {
        if (index == s.length()) {
            found = true;
            return;
        }
        if (found) {
            return;
        }
        for (int i = index + 1; i <= s.length(); i++) {
            if (dict.contains(s.substring(index, i))) {
                dfs(s, i);
            }
        }
    }
}
```
ä¼˜åŒ–åè¿™æ®µä»£ç ï¼Œæ€»çš„æ—¶é—´å¤æ‚åº¦ä¾ç„¶æ˜¯æŒ‡æ•°çº§çš„ `O(2^N * N^2)`ï¼Œæ˜¯æ— æ³•é€šè¿‡æ‰€æœ‰æµ‹è¯•ç”¨ä¾‹çš„ï¼Œé‚£ä¹ˆé—®é¢˜å‡ºåœ¨å“ªé‡Œå‘¢ï¼Ÿ

æ¯”å¦‚è¾“å…¥ wordDict = ["a", "aa"], s = "aaab"ï¼Œç®—æ³•æ— æ³•æ‰¾åˆ°ä¸€ä¸ªå¯è¡Œçš„ç»„åˆï¼Œæ‰€ä»¥ä¸€å®šä¼šéå†æ•´æ£µå›æº¯æ ‘ï¼Œä½†ä½ æ³¨æ„è¿™é‡Œé¢ä¼šå­˜åœ¨é‡å¤çš„æƒ…å†µï¼š
![alt text](../static/1.jpg)

å¦‚æœä»åå¾€å‰çœ‹ 

## Approach3 -> DP + DFS å¸¦å¤‡å¿˜å½•çš„ DFS ç®—æ³•

```java
// å®šä¹‰ï¼šè¿”å› s[i..] æ˜¯å¦èƒ½å¤Ÿè¢«æ‹¼å‡º
int dp(String s, int i);

// è®¡ç®—æ•´ä¸ª s æ˜¯å¦èƒ½è¢«æ‹¼å‡ºï¼Œè°ƒç”¨ dp(s, 0)
```
memo[len]
memo[i] = 1 -> ä» index i åˆ° tail å¯ä»¥ç”±å­—å…¸æ„æˆ        
memo[i] = -1 -> ä» index i åˆ° tail ä¸å¯ä»¥ç”±å­—å…¸æ„æˆ     
memo[i] = 0 -> ä» index i åˆ° tail è¿˜æ²¡æœ‰è¢«çœ‹è¿‡

```java
class Solution {
    // ç”¨å“ˆå¸Œé›†åˆæ–¹ä¾¿å¿«é€Ÿåˆ¤æ–­æ˜¯å¦å­˜åœ¨
    HashSet<String> wordDict;
    // å¤‡å¿˜å½•ï¼Œ-1 ä»£è¡¨æœªè®¡ç®—ï¼Œ0 ä»£è¡¨æ— æ³•å‡‘å‡ºï¼Œ1 ä»£è¡¨å¯ä»¥å‡‘å‡º
    int[] memo;

    // ä¸»å‡½æ•°
    public boolean wordBreak(String s, List<String> wordDict) {
        // è½¬åŒ–ä¸ºå“ˆå¸Œé›†åˆï¼Œå¿«é€Ÿåˆ¤æ–­å…ƒç´ æ˜¯å¦å­˜åœ¨
        this.wordDict = new HashSet<>(wordDict);
        // å¤‡å¿˜å½•åˆå§‹åŒ–ä¸º -1
        this.memo = new int[s.length()];
        Arrays.fill(memo, -1);
        return dp(s, 0);
    }

    // å®šä¹‰ï¼šs[i..] æ˜¯å¦èƒ½å¤Ÿè¢«æ‹¼å‡º
    boolean dp(String s, int i) {
        // base case
        if (i == s.length()) {
            return true;
        }
        // é˜²æ­¢å†—ä½™è®¡ç®—
        if (memo[i] != -1) {
            return memo[i] == 0 ? false : true;
        }

        // éå† s[i..] çš„æ‰€æœ‰å‰ç¼€
        for (int len = 1; i + len <= s.length(); len++) {
            // çœ‹çœ‹å“ªäº›å‰ç¼€å­˜åœ¨ wordDict ä¸­
            String prefix = s.substring(i, i + len);
            if (wordDict.contains(prefix)) {
                // æ‰¾åˆ°ä¸€ä¸ªå•è¯åŒ¹é… s[i..i+len)
                // åªè¦ s[i+len..] å¯ä»¥è¢«æ‹¼å‡ºï¼Œs[i..] å°±èƒ½è¢«æ‹¼å‡º
                boolean subProblem = dp(s, i + len);
                if (subProblem == true) {
                    memo[i] = 1;
                    return true;
                }
            }
        }
        // s[i..] æ— æ³•è¢«æ‹¼å‡º
        memo[i] = 0;
        return false;
    }
}
```

## Approach4 -> DP -> O(n^3)
```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> set = new HashSet<>();
        for (String word : wordDict) {
            set.add(word);
        }
        boolean[] memo = new boolean[s.length() + 1];
        // memo[i] -> s.substring(0, i) æ˜¯å¦å¯ä»¥ç»„æˆ
        memo[0] = true;
        // ä»€ä¹ˆéƒ½æ²¡æœ‰çš„æ—¶å€™æ˜¯ true
        for (int i = 1; i <= s.length(); i++) {
            for (int j = i - 1; j >= 0; j--) {
                if (memo[j] && set.contains(s.substring(j, i))) {
                    memo[i] = true;
                    break;
                }
            }
        }
        return memo[memo.length - 1]; 
    }
}
```